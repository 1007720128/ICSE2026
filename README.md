# AdaptiveScaler: Collaborative Autoscaling for Microservices with Adaptive Dependency Learning

This repository provides the official implementation and artifacts for the ICSE paper, "AdaptiveScaler: Collaborative Autoscaling for Microservices with Adaptive Dependency Learning". This work introduces a novel autoscaling algorithm designed to guarantee Quality of Service (QoS) for microservice applications in complex, heterogeneous edge-cloud environments.

## Overview

AdaptiveScaler is a learning-based autoscaler that requires a sophisticated runtime environment, including Kubernetes for container orchestration and Prometheus for performance monitoring. To facilitate evaluation and provide reviewers with a direct understanding of the algorithm's effectiveness, we have integrated a **self-contained simulation environment**. This allows for immediate execution and observation of the core algorithm without the need to set up the entire distributed infrastructure.

For those interested in real-world deployment, this repository also includes all necessary auxiliary code for interacting with a live system, such as Kubernetes operators, Prometheus metric queries, and Gatling-based traffic injectors.

**Note:** For real-world deployment, certain placeholder values (e.g., directory paths, host IPs, API keys) have been anonymized for privacy. You will need to replace these with your specific configuration details.

## Quick Start: Running the Simulation

The fastest way to see AdaptiveScaler in action is to run the main entry point, which leverages the integrated simulation environment.

```bash
python runner.py
```

Executing this script will automatically:
1. Initialize the simulated edge-cloud environment.
2. Train the AdaptiveScaler model from scratch.
3. Evaluate the trained model and report the performance metrics.

## Repository Structure

The repository is organized as follows:

* `runner.py`: **Main Entry Point.** This script orchestrates the entire simulation, including environment setup, model training, and evaluation.

* `dataset/`: Contains the workload traces used in our experiments.
    * `Injection.java`: The Gatling script used for injecting traffic into the system.

* `algos/`: **Core Algorithm Implementation.**
    * `AdaptiveScaler.py`: The main file implementing the AdaptiveScaler algorithm. This file directly maps to the core contributions of our paper:
        * **C1: Adaptive Dependency Learning**: Implemented within the `GraphConvDependencyLearning` class, which autonomously learns performance-critical paths.
        * **C2: Heterogeneity-Aware Cooperative Training**: Implemented in the `HeteroContextAttention` class, which enables intelligent, attention-driven coordination among agents.
        * **C3: Synergistic Distributed Architecture**: Realized through the overall Actor-Critic structure and the training loop, which orchestrates distributed decision-making.

* `onpolicy/`: Contains auxiliary classes and utilities utilized by the reinforcement learning algorithm.

* `helper/`: Contains helper classes for real-world system interaction.
    * `kubernetes_helper.py`: Implements the logic to translate scaling actions into `kubectl` commands.
    * `query_helper.py`: Implements the logic to query and parse metrics from a Prometheus server.
    * `util.py`: Provides utilities for analyzing system state from various sources.

## Extending to Your Own Environment

AdaptiveScaler is designed for high portability. To adapt it to a new environment, you need to implement three key interface functions to bridge the algorithm with your specific system:

1.  **Implement `get_state()`:**
    This function should be responsible for collecting and returning the state of your environment. You may need to adjust the input dimensions of the model in `AdaptiveScaler.py` to match the shape of your state representation.

2.  **Implement `reward()`:**
    Define a reward function that reflects your specific business objectives and QoS targets. This function guides the reinforcement learning process to learn policies that satisfy your custom requirements.

3.  **Implement `step()`:**
    This function takes the scaling actions generated by AdaptiveScaler (e.g., `+1`, `-2`) and translates them into concrete commands for your orchestration system (e.g., updating a Kubernetes deployment manifest).

By implementing these three functions, you can seamlessly integrate AdaptiveScaler into virtually any microservice-based system.
